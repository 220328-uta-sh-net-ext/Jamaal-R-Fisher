In software engineering, service-oriented architecture (SOA) is an architectural style that supports service orientation.
By consequence, it is as well applied in the field of software design where services are provided to the other components by application components, through a communication protocol over a network.
A service is a discrete unit of functionality that can be accessed remotely and acted upon and updated independently, such as retrieving a credit card statement online.
SOA is also intended to be independent of vendors, products and technologies.

an architecture which most IT giants use to handle their enterprise more effectively and in a more agile way.
a Middleware solution which makes two or more systems or applications talk to each other.


Service orientation is a way of thinking in terms of services and service-based development and the outcomes of services.

A service has four properties according to one of many definitions of SOA:
-- It logically represents a repeatable business activity with a specified outcome.
-- It is self-contained.
-- It is a black box for its consumers, meaning the consumer does not have to be aware of the service's inner workings.
-- It may be composed of other services.


SOA means that you structure your application by decomposing it into multiple services (most commonly as HTTP services) that can be classified as different types like subsystems or tiers.

Those services can now be deployed as Docker containers, which solves deployment issues, because all the dependencies are included in the container image.
However, when you need to scale up SOA applications, you might have scalability and availability challenges if you're deploying based on single Docker hosts.
This is where Docker clustering software or an orchestrator can help you, as explained in later sections where deployment approaches for microservices are described.


HTML + PHP (web server service) + MySQL (database service)

i2s (integer to string)

b2h (binary to hexadecimal)

services + messages


when systems talk with each other, the dependency which is required to talk is minimal.

failure of one system does not impact on other system.

______________________________________________

Postman team link:  https://app.getpostman.com/join-team?invite_code=f6ad5f63318434cb0894fc8f96bb3568

__________________________________________________


Representational State Transfer (REST) as an architectural approach to designing web services.
REST is an architectural style for building distributed systems based on hypermedia.
REST is independent of any underlying protocol and is not necessarily tied to HTTP.
However, most common REST API implementations use HTTP as the application protocol, and this guide focuses on designing REST APIs for HTTP.

A primary advantage of REST over HTTP is that it uses open standards, and does not bind the implementation of the API or the client applications to any specific implementation.
For example, a REST web service could be written in ASP.NET, and client applications can use any language or toolset that can generate HTTP requests and parse HTTP responses.


REST APIs use a uniform interface, which helps to decouple the client and service implementations.
For REST APIs built on HTTP, the uniform interface includes using standard HTTP verbs to perform operations on resources.


1-tier vs. 2-tier vs. 3-tier architecture


SOAP vs REST

Guiding principles of SOA

HTTP Life Cycle

HTTP requests & responses


https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview
restfulapi.net


* UI becomes the API in P0
__________________________________________________________________________________________


SOAP (formerly a backronym for Simple Object Access Protocol) is a messaging protocol specification for exchanging structured information in the implementation of web services in computer networks.
It uses XML Information Set for its message format, and relies on application layer protocols,
most often Hypertext Transfer Protocol (HTTP), although some legacy systems communicate over Simple Mail Transfer Protocol (SMTP), for message negotiation and transmission.

SOAP allows developers to invoke processes running on disparate operating systems (such as Windows, macOS, and Linux) to authenticate, authorize, and communicate using Extensible Markup Language (XML).
Since Web protocols like HTTP are installed and running on all operating systems, SOAP allows clients to invoke web services and receive responses independent of language and platforms.

______________________________________________________________________________________________

Guiding principles of SOA


Standardized Service Contract
Services adhere to a service-description. A service needs to have some information that defines what the service is about.

Loose Coupling
Services minimize dependencies on each other. So if the service functionality breaks at several points in time, this should not crush the client application or stop it from running.

Service Abstraction
Services wrap the logic they encapsulate from the unknown external world. The service shouldn't show how it performs its functionality.

Service Reusability
Logic is divided into services to maximize re-use.

Service Autonomy
Services must control the logic they encapsulate.

Service Statelessness
Services should stay stateless. This determines that services should not keep data from one state to the other. This would be required to be done from each client application.

Service Discoverability
Services can be discovered (usually in a service registry). We have previously viewed this in the theory of the UDDI, which performs a registry which can contain information about the web service.

Service Composability
It breaks large problems into tiny problems.

Service Interoperability
Services should use standards that provide different supporters to use the service. This is examined so obviously these days that it is frequently dropped as a principle.




_______________________________________________________________________________________________


HTTP verbs/request methods

The most common operations are GET, POST, PUT, PATCH, and DELETE.


GET retrieves a representation of the resource at the specified URI. The body of the response message contains the details of the requested resource.
POST creates a new resource at the specified URI. The body of the request message provides the details of the new resource. Note that POST can also be used to trigger operations that don't actually create resources.
PUT either creates or replaces the resource at the specified URI. The body of the request message specifies the resource to be created or updated.
PATCH performs a partial update of a resource. The request body specifies the set of changes to apply to the resource.
DELETE removes the resource at the specified URI.



Resource		POST					GET					PUT						DELETE
/customers		Create a new customer			Retrieve all customers			Bulk update of customers			Remove all customers
/customers/1		Error					Retrieve the details for customer 1	Update the details of customer 1 if it exists	Remove customer 1
/customers/1/orders	Create a new order for customer 1	Retrieve all orders for customer 1	Bulk update of orders for customer 1		Remove all orders for customer 1




The differences between POST, PUT, and PATCH can be confusing:

A POST request creates a resource. The server assigns a URI for the new resource, and returns that URI to the client.
In the REST model, you frequently apply POST requests to collections. The new resource is added to the collection.
A POST request can also be used to submit data for processing to an existing resource, without any new resource being created.

A PUT request creates a resource or updates an existing resource. The client specifies the URI for the resource.
The request body contains a complete representation of the resource. If a resource with this URI already exists, it is replaced.
Otherwise a new resource is created, if the server supports doing so. PUT requests are most frequently applied to resources that are individual items, such as a specific customer, rather than collections.
A server might support updates but not creation via PUT. Whether to support creation via PUT depends on whether the client can meaningfully assign a URI to a resource before it exists.
If not, then use POST to create resources and PUT or PATCH to update.

A PATCH request performs a partial update to an existing resource. The client specifies the URI for the resource.
The request body specifies a set of changes to apply to the resource. This can be more efficient than using PUT, because the client only sends the changes, not the entire representation of the resource.
Technically PATCH can also create a new resource (by specifying a set of updates to a "null" resource), if the server supports this.

PUT requests must be idempotent. If a client submits the same PUT request multiple times, the results should always be the same (the same resource will be modified with the same values).
POST and PATCH requests are not guaranteed to be idempotent.


___________________________________________________________________________________________


In 2008, Leonard Richardson proposed the following maturity model for web APIs:

Level 0: Define one URI, and all operations are POST requests to this URI.
Level 1: Create separate URIs for individual resources.
Level 2: Use HTTP methods to define operations on resources.
Level 3: Use hypermedia (HATEOAS, described below).



HATEOAS (Hypertext as the Engine of Application State)

One of the primary motivations behind REST is that it should be possible to navigate the entire set of resources without requiring prior knowledge of the URI scheme.
Each HTTP GET request should return the information necessary to find the resources related directly to the requested object through hyperlinks included in the response,
and it should also be provided with information that describes the operations available on each of these resources. This principle is known as HATEOAS, or Hypertext as the Engine of Application State.
The system is effectively a finite state machine, and the response to each request contains the information necessary to move from one state to another; no other information should be necessary.



Versioning enables a web API to indicate the features and resources that it exposes, and a client application can submit requests that are directed to a specific version of a feature or resource.

No versioning
URI versioning
Query string versioning
Header versioning
Media type versioning



______________________________________________________________________________________________________

HTTP actions enable users to interact with APIs and send web requests that perform various operations, such as uploading and downloading data and files.

To send an API request, like POST, GET, PUT, or DELETE, you can use the Invoke web service action.

In the action's properties, you have to populate the service's URL and the appropriate HTTP method. Additionally, you have to choose the request and response content type, such as XML and JSON.

The Custom headers and Request body fields depend on the API, and you have to configure them as described in its documentation.


__________________________________________________________________________



only console apps vs. testable methods (what if we want to use this function in a mobile app, web app, API?)

public void Addition(){}

vs.

public double Addition(int a, int b){}



refactoring
decoupling

___________________________________________________________________________________


UI, BL, DL -----> database, http
when all the layers are in the same machine, it is a 1-tier application.  Ex - Notepad.



2-tier application.

client:			request					server (IP address):
UI, some BL        ---------------->			may be DL, may be DB
			response

			HTTP

when UI is deployed separately and so is the BLI and/or DL and/or DB.   Ex - website.




client side technologies
- HTML/CSS/JavaScript (also nowadays server side)
- Angular/react


server side technologies
- .Net (C#)
- Java, php etc....


backend/database
- SQL Server, Azure SQL
- Oracle, IBM, Postgres, MySQL


cloud technologies
-Azure, Google, AWS, IBM, etc...


_________________________________________________________________________________________________



https://localhost<portnumber>/api/ControllerName



______________________________________________________________________________________________



Asp.Net Core Pipeline														HttpContext
													HttpRequest
													HttpResponse

Firewall  -------------->   Routers ------------------------------------------------>			Middleware 1
	  <--------------	
				^									Middleware 2
				|	
				|									Routing
Client/				|									RouteTable
User-Agent/			|
Browser/			|
				|									Controller
				|
				|									Action(Parameters)  <----------  ModelBinder
				|
				------------------------------------------------------>			HttpResponse

_________________________________________________________________________________________________

Model Binding

It is a way to bind data (JSON objects) coming from HTTP request to be automatically mapped into a C# model

QueryString --->  Primitive types
RequestBody --->  Complex types




Parameter Binding




__________________________________________________________________________________________________

Reporting on Delegates, anonymous methods, lambda expression, and LINQ

Delegates - https://www.tutorialsteacher.com/csharp-delegates
Blake, Daniel, Emeka, Jermaine, Jamaal

Linq - https://www.tutorialsteacher.com/linq


________________________________________________________________________________________


delegates

definition - type safe function pointers.
can be used to pass methods as parameters.
can be used to decouple the methods of same type as of delegate with classes, because class instance can be heavy at times.
we can create anonymous methods with delegates and Lambda in shorthand notation for anonymous methods which means they also implicitly use delegates.

types:
single-cast delegates - where a delegate is tied to 1 method of same type as delegate
multicast delegates - where a delegate is tied to more than one method of same type as delegate

predefined delegates:
Func <type, type>()	-- returns a value
Action <type>()		-- type void
Predicate <bool>()	-- returns a boolean

we can use delegates for event driven-programming.

events are any user defined action (mouse click, hover, pressing keys).
they are triggered on user's action and needs to be handled as an after trigger behavior.


___________________________________________________________________________________________________

LINQ
a query is a first-class language construct, just like classes, methods, events. You write queries against strongly typed collections of objects by using language keywords and familiar operators.
The LINQ family of technologies provides a consistent query experience for objects (LINQ to Objects), relational databases (LINQ to SQL), and XML (LINQ to XML).

For a developer who writes queries, the most visible "language-integrated" part of LINQ is the query expression. Query expressions are written in a declarative query syntax.
By using query syntax, you can perform filtering, ordering, and grouping operations on data sources with a minimum of code.
You use the same basic query expression patterns to query and transform data in SQL databases, ADO.NET Datasets, XML documents and streams, and .NET collections.

You can write LINQ queries in C# for SQL Server databases, XML documents, ADO.NET Datasets, and any collection of objects that supports IEnumerable or the generic IEnumerable<T> interface.
LINQ support is also provided by third parties for many Web services and other database implementations.
